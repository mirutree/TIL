---  

#### ⭐OS란? 어떤 역할을 하는지
- 운영체제(Operating System)는 사용자와 컴퓨터 사이에서 사용자가 컴퓨터를 편리하고 효과적으로 사용하기 위한 시스템 소프트웨어다.    
- 운영체제의 목적
  - 하드웨어 및 소프트웨어 자원을 효율적으로 할당하고 관리한다.
  - 사용자 프로그램의 오류나 잘못된 자원사용을 감시하고 제어한다.
- 운영체제의 종류
  - Windows, UNIX, Linux, Mac OS, iOS 등이 있다.
  - 단일 작업 처리 시스템에는 DOS, 다중 작업 처리 시스템에는 WINODWS, UNIX, LINUX등이 사용된다.
  - Windows는 개인용 Unix, Linux는 서버용 운영체제로 주로 사용된다.
---      
#### ⭐리눅스란? 
- 리눅스는(Linux)는 다중 사용자와 다중 작업(멀티태스킹, 멀티 쓰레드)를 지원하는 네트워크 운영체제(NOS)다.
- 1991년 핀란드의 리누스 토발즈(Linus Torvalds)에 의해 UNIX운영체제를 기반으로 만들어졌다 
- 프리 소프트웨어중 하나로 누구나 자유롭게 수정이 가능하다. 배포판이 아닌 리눅스 자체는 무료다.
- 오픈소스이기 때문에 수많은 버전의 리눅스가 있으며 대표적으로 레드햇의 센토스OS와 데비안의 우분투OS가 있다
  - 우분투
    - 데비안 프로젝트라는 공동체에서 만들어진 리눅스 배포판이다.
    - 초보자들도 쉽게 접근할 수 있으며, 데스크탑용 배포판 중 가장 많이 사용된다. 
  - 센토스
    - Red Hat이 공개한 RHEL을 그대로 가져와서 사용하고 있기에 RHEL 과 OS 버전, Kernel 버전, 패키지 구성이 똑같고 바이너리가 100%로 호환된다.
    - 서버용 운영체제로 인기가 높다.
- 리눅스의 구조
  1. 커널(kernel) 
        - 하드웨어와 가장 가까이 있는 가장 핵심적인 프로그램으로 커널을 통해 하드웨어를 제어하고 시스템의 자원을 관리한다.
  2. 쉘(Shell)
      - 사용자의 응용 프로그램과 커널 사이에 위치해있다. 
      - 사용자가 명령어를 입력하면 쉘이 명령어를 받아 해석해서 커널에게 보내면 커널은 사용자가 내려주었던 동작을 실행하고 그에대한 결과가 쉘을거쳐 다시 사용자에게 온다.
      - Bourne Shell (/bin/sh) : 본쉘. 유닉스 최초의 쉘.
      - Bash, Bourne Again Shell (/bin/bash) : 현재 리눅스에서 표준으로 채택된 쉘. Mac 운영체제에서도 bash가 쓰인다.
      - C shell (/bin/csh) : C언어 기반으로 만들어진 쉘. 쉘 스크립트를 C언어로 작성하는 것처럼 작성할 수 있다.
      - 사용자가 어떤 쉘을 쓰고 있는지 알고 싶다면 SHELL 환경변수를 확인한다 `/home/ubuntu# echo $SHELL`
  3. 응용프로그램(Application)
- 리눅스의 디렉토리 구조
  - 리눅스는 전체적으로 트리 구조를 하고 있으며, 터미널 모드에서 cd를 이용하여 원하는 폴더로 이동할 수 있다.
  - `/root`라는 최상위 디렉토리가 존재하고 그 밑에 bin, boot, dev, etc등이 있으며 각 디렉토리 밑에 하위 디렉토리가 있다.
  - 루트 바로 밑에 있는 디렉토리들은 리눅스를 실행하는데 있어 매우 중요한 역할을 수행한다.
    1. `/bin` : 리눅스의 기본 명령어들이 들어있다. 사용자가 일번적으로 사용하는 ls나 cat같은 명령어들이 위치하고 있다.
    2. `/boot` : 부팅에 핵심적인 커널 이미지와 부팅 정보 파일을 담고 있다.
    3. `/dev ` : 시스템 디바이스 파일을 저장하고 있다.
    4. `/etc ` : 
        - 시스템 환경 설정파일이 있다.
        - `/etc/rc` :  /bin/sh 쉘이 부팅되면 자동적으로 실행되는 스크립트파일이 들어있다. 이러한 스크립트는 update, crond, inetd 같은 프로그램을 백그라운드로 실행시킨다.
        - `/etc/init` : 부팅시에 커널에 의해 가장 먼저 실행된다. init이 실행된 후에 커널 부팅이 완료가 되고 /etc/rc.d/rc와 로그인 관련한 getty 등을 실행하게 된다.
    5. `/home` : 로그인을 했을 때 처음으로 위치하는 디렉토리
    6. `/lib `: 부팅과 시스템 운영에 필요한 공유 라이브러리와 커널 모듈이 위치한다.
    7. `/proc` : 가상파일 시스템. 현재 메모리에 존재하는 작업들이 파일 형태로 존재하는 폴더
    8. `/sbin`: 시스템 관리를 위한 전반적인 실행 유틸리티. ifconfig같은 명령어가 위치한다
    9. `/temp` : 프로세스 진행 중 발생하는 임시 파일들이 저장되는 작업 디렉토리. stic bit이라는 특수권한이 설정되어 있어서 파일의 소유자만이 삭제가 가능하다.
    10. `/usr` : 
        - 일반 사용자를 위한 대부분의 프로그램 라이브러리 파일들이 위치한다.
        - `/usr/bin` : 응용 프로그램의 실행 파일이 위치한다.
        - `/usr/sbin` : 주로 네트워크 관련 실행 명령어와 실행 데몬들을 포함한다.
        - `/usr/include` : 기본 c 라이브러리 헤더파일과 각종 라이브러리 헤더 파일들이 존재한다.
        - `/usr/lib` : /usr/bin과 /usr/sbin에 있는 실행 바이너리를 실행하기 위한 라이브러리가 존재한다.
        - `/usr/src` : 프로그램 소스 및 커널 소스들이 보관되어 있다.
    11. `/var` : 시스템에서 사용되는 동적인 파일들(주로 시스템 로그)이 저장된다. 시스템 운영 중에 시스템 자료 데이터가 변경되면 해당 변경 내용이 이곳에 저장된다.
---
#### ⭐클라우드 서비스란? 
- 추가로 소프트웨어를 다운로드하지 않고도 인터넷을 통해 사용자가 액세스하는 모든 인프라, 플랫폼, 소프트웨어 또는 기술
- 타사 제공업체가 호스팅하여 인터넷을 통해 사용자에게 인프라, 플랫폼 또는 소프트웨어를 제공한다.
- 클라우드 서비스의 장점 
    1. 경제성 : 
        - 클라우드 서비스는 사용기간을 사용자가 합리적으로 선택할 수 있다. 
        - 소프트웨어와 데이터를 클라우드에서 통합 관리하기 때문에 업데이트 및 데이터 유지보수의 효율성을 높인다.
    2. 유연성 :
        - 컴퓨팅 리소스를 필요할 때 필요한 만큼 확장하고, 필요하지 않을 때는 축소할 수 있어 유연하게 활용할 수 있다. 
        - 어느정도의 인프라가 필요할지 예상을 하고 구축하여 추가적 확장이 어려웠던 예전 방식과 다르게, 클라우드 서비스를 사용하면 규모 확장이 필요할 때 그에 맞게 인프라를 비교적 쉽게 빌려올 수 있다. 
    3. 가용성 :
        - 일부 하드웨어에 장애가 발생하더라도 서비스는 계속해서 사용할 수 있도록 구성되어 있다.
    4. 빠른 구축 속도
        - 클라우드가 제공하는 하드웨어와 소프트웨어를 이용해 시스템을 신속하게 구축 가능하다. 
        - 서비스를 주문을 하고 2-3주가 걸렸던 기존의 방식과 달리, 클라우드는 10분 내로 인프라를 도입하고 서비스를 구축할 수 있다. 따라서 인프라를 도입하는 시간을 줄여 서비스 배포 시기를 앞당길 수 있다.
---   
#### ⭐서버와 웹서버의 기본 개념과 둘의 차이점. 아파치와 nginx의 장단점 
- 서버란?
  - 서버(Server)는 클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터. 또는 그 역할을 수행하는 기능.
  - 서버는 역할에 따라 다양하게 구분되며 그중 웹 서버는 웹사이트를 관리하는 서버이다. 
- 웹서버란?
  - Web Server는 하드웨어, 소프트웨어 혹은 두개가 같이 동작하는 것을 의미한다.
    1. 하드웨어적 웹서버는 웹사이트의 컴포넌트 파일들을 저장하는 컴퓨터이다. 웹서버는 웹에 연결된 다른 기기들이 웹서버의 데이터를 주고받게 한다.
    2. 소프트웨어적 웹서버는 웹사용자가 어떻게 호스트 파일들에 접근하는지 관리한다. HTTP를 통해 클라이언트의 요청에 대한 응답을 보낸다.
  - 대표적인 웹서버의 종류로는 Apache, IIS, Nginx 등이 있다.
- 아파치 Apache WEB Server
  - 가장 대표적인 웹서버로 1995년부터 현재까지 가장 많이 쓰이고 있다.
  - 아파치 서버는 요청 당 하나의 프로세스(또는 스레드)가 처리하는 구조이다. 요청이 많을수록 CPU와 메모리 사용이 증가하여 성능저하가 있다. 
- 엔진엑스(엔지닉스) Nginx
  - 프로그램의 흐름이 이벤트에 의해 결정이 되는 Event Driven  방식의 웹서버이다.
  - 모듈개발이 어렵고 다양한 모듈이 없다
- Apache와 Nginx 비교
  - 엔진엑스는 비동기 이벤트 기반으로 요청을 처리하고, 아파치 서버는 요청당 스레드 또는 프로세스가 처리하는 구조이다.
  - 최근 대용량의 정적파일 및 큰 규모의 사이트가 많아짐에 따라 대량 접속에도 적은 리소스를 사용하며 빠르게 서비스할 수 있는 웹사이트가 대세가 되었다. 이런 면에서 엔진엑스가 각광받기 시작했다.
  - 아파치도 응답속도와 리소스 사용을 개선한 Apache 2.4를 발표하면서 엔진엑스에 대응하기 시작했다.
  - 아파치는 PHP모듈 등을 직접 적재할 수 있는 구조상 이점이 있대 때문에 복잡한 웹사이트의 경우 아파치가 적합하다.   
  - 별도의 세팅작업이 필요한 경우에도 아파치는 유지보수가 유용하다   
  - 종합적으로는 안정성, 확장성, 호환성 면에서는 아파치가, 성능 면에서는 엔진엑스가 우세하다
---
#### ⭐웹팩과 바벨의 기본 개념
---
#### ⭐도메인과 네임서버의 기본 개념
---
#### ⭐TCP / IP 
---
#### ⭐http 의 기본개념과 https 란 무엇인지
---
#### ⭐sync 와 async 의 차이
---
#### ⭐로드밸런싱
- 로드밸런싱(Load Balancing)이란?
  - '부하분산'이라고도 부르며 컴퓨터 네트위크 기술의 일종이다.
  - 여러 중앙처리장치나 저장장치가 같은 컴퓨터 자원들에게 작업을 나누는 것이다
  - 사업이 확장되어 트래픽이 증가하게 되면 서버를 고성능 장비로 대체하여(Scale up) 처리 능력을 향상시키거나 접속된 서버의 대수를 늘려(Scale out) 향상시킨다
  - 스케일 아웃 방식으로 여러 서버를 둔다면 트래픽이 각 서버마다 골고루 분산되어야 부하가 생기지 않이 때문에 자원을 나누는 작업을 Load balancing이라고 하고 작업을 담당하는 장비를 Load balancer라고 한다
- 주요기능
  - NAT(Network Addres Translation)
    - 사설 ip를 공인 ip주소로 바꾸는 데 사용하는 통신망의 주소 변조기
  - Tunneling
    - 인터넷상에서 눈에 보이지 않는 통로를 만들어 통신할 수 있게 하는 개념
    - 데이터를 캡슐화해서 연결된 상호 간에만 캡슐화된 패킷을 구별하여 캡슐화를 해제할 수 있다.
  - DSR(Dynamic Source Routing protocol)
    - 로드밸런서 사용 시 서버에서 클라이언트로 되돌아가는경우 목적지 주소를 스위치의 ip주소가 아닌 클라이언트의 ip주소롤 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념
- 로드밸런싱 종류
    - 로드밸런서는 OSI계층을 기준으로 어떻게 부하를 분산하는지에 따라 종류가 나뉜다.
    - 2계층을 기준으로 부하를 분산하면 L2, 3계층을 기준으로 부하를 분산하면 L3이다.
    - 상위 계층으로 갈수록 섬세한 부하분산이 가능하고 가격이 비싸진다.   
          
    |종류|||
    |------|---|---|
    |L2|Data link 계층을 사용, Mac주소 기반 부하 분산||
    |L3|Network 계층을 사용, IP주소 기반 부하 분산	||
    |L4|Transport 계층을 사용, Port 기반 부하 분산|TCP, UDP|
    |L7|Application 계층을 사용, 요청(URL) 기반 부하 분산|HTTP, HTTPS 등|
   
---
#### ⭐Restful API에서의 URL과 일반적인 HTTP에서의 URL의 차이는?
---
#### ⭐프록시 서버와 기능?
 - 프록시(Proxy)란? 
    - 프록시(Proxy)란 ‘대신’ 이라는 의미를 가지고 있고, 프로토콜에 있어서 대리 응답으로 사용하는 개념
    - 컴퓨터 네트워크에서 다른 서버 상의 자원을 찾는 클라이언트로부터 요청을 받아 중계하는 서버
    - 네트워크 상에서 클라이언트의 요청을 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해준다.
 - 프록시 서버의 기능 (응답시간 단축, 네트워크 병목현상 방지, 보안 강화)
   - 클라이언트가 서버로부터 필요한 파일, 연결, 웹 페이지 등과 같은 자원을 프록시 서버에 요청하면 프록시 서버는 클라이언트와의 사이에서 대신 통신을 수행한다.
   - 프록시 서버에는 클라이언트로부터 원격에 요청된 자원들이 캐시되어 임시로 저장되어 있다
   - 캐싱을 통해 콘텐츠를 빠르게 가져올 수 있다.
   - 따라서 데이터 전송 시간과 외부 트래픽이 줄어들고 서버 측의 네트워크 병목 현상을 방지할 수 있다.
   - 내부 통신과 외부 데이터 접근을 통제할 때 사용하기 때문에 한단계의 중계를 거치므로 악성코드 전달을 목적인 웹 컨텐츠를 프록시 서버를 통해 필터링하여 보안을 향상시키기 위한 목적으로 사용한다.
   - 인터넷 이용률 통계를 수집하기 위해 프록시 서버를 사용하기도 한다. 로그가 남기 때문에 분석을 하는데 사용할 수 있다.
 - 프록시 서버의 역기능
    - 사용자의 입장에서 자신의 웹 서핑 기록을 익명화하기 위해 익명 웹 프록시(anonymizer)를 사용한다. 중계서버를 거쳐서 넘어가기 때문에 자신의 IP기록이 남지 않게 만들 수 있다
---
#### ⭐쿠키와 세션의 차이
---
#### ⭐FTP 와 SFTP란?
---
#### ⭐Node.js?
 - Chrome의 V8 JavaScript 엔진으로 빌드 된 `JavaScript 런타임 환경`이다.
 - 웹서버와 같은 확장성 있는 네트워크 애플리케이션(특히 서버사이드) 개발에 사용되는 소프트웨어 플랫폼.
 - Node.js는 JavaScript를 서버에서도 사용할 수 있도록 만든 프로그램이다.
 - 다양한 JavaScript 애플리케이션을 실행할 수 있지만 서버를 실행하는데 가장 많이 사용된다.
 - 비동기 I/O 처리(Non-Blocking I/O)와 단일 스레드 이벤트 루프를 통해 높은 처리성능을 가지고 있다.
 - 내장 HTTP서버 라이브러리를 포함하고 있다. 
 - 2009년 Ryan Dahl(라이언 달)이라는 개발자가 개발하였고, 2012년에 프로젝트에서 물러났다가 2018년 Deno라는 새로운 런타임을 발표했다.
 - **Google Chrome V8 엔진**?
    - 구글 크롬과 Node.js에서 사용되고 있는 구글에서 제작한 자바스크립트 엔진
    - C++로 작성되었고 자바스크립트 전용의 웹 어셈블리 엔진이다.
    - 자바스크립트 엔진은 코드 한 줄을 해석하고 바로 실행하는 인터프리터 형식이지만, V8엔진은 자바스크립트 코드를 ByteCode로 컴파일하고 실행하는 방식을 사용한다.
    - V8엔진은 독립형으로 개발되었기 때문에 웹 브라우저 뿐 아니라 C++프로그램에 별도로 내장하여 실행시킬 수 있다.
    - 그렇기에 C++로 작성한 언어를 V8엔진을 이용하여 자바스크립트에서 동작할수 있기 때문에 순수자바스크립트보다 더 많은 일을 할 수 있다.  
 - **Node.js 사용이유?**
    - 자바스크립트는 스크립트 언어이기 때문에 웹 브라우저 프로그램 안에서만 동작한다.
    - Node.js는 자바스크립트를 웹 브라우저에서 독립시켰기 때문에 Node.js를 설치하게 되면 터미널 프로그램에서 바로 실행할 수 있다.
    - 이전까지는 Server-Client웹사이트를 만들 때는 웹에서 표시되는 부분 말고는 서버 부분에 자바스크립트를 사용할 수 없었지만 Node.js를 이용하여 자바스크립트만으로 전체 웹페이지를 만들 수 있게 되었다.
 - **자바스크립트 런타임***
    - 런타임이란? 특정 언어로 만든 **프로그램을 실행할 수 있는 환경**
    - Node.js는 Javascript 프로그램을 컴퓨터에서 실행할 수 있게 하는 자바스크립트 실행기이다.
 - **이벤트 기반**
    - Node.js는 V8과 더불어 Libuv(리버브)라는 라이브러리를 사용한다.
    - Libuv 라이브러리는 노드의 특성인 이벤트기반, 논 블로킹 I/O 모델을 구현하고 있다.
    - 이벤트 기반(Event-driven)이란? 이벤트가 발생할 때 미리 지정해 둔 작업을 수행하는 방식
    - 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 어떤 종작을 실행할지 미리 등록해두고 이를 이벤트 리스너에 콜백함수로 등록한다.
    - 이벤트가 발생하면 리스너에 등록해둔 콜백할수를 호출하고, 이벤트가 끝나면 다음이벤트가 발생할 때 까지 대기한다.
    - 이벤트 루프? 이벤트 루프(Event loop)는 여러가지 이벤트가 동시에 발생하는 경우 어떤 순서로 콜백함수를 할지 판단하는 어떠한 구조이다.
- **Non-Blocking I/O(입출력)**
    - Node.js에서는 모든 API가 비동기 방식이다. 호추 후 응답을 기다리지 않고 다른 API를 호출한다.
    - 이전에 호출했던 API의 응답이 오면 이벤트 루프가 확인하여 처리한다.
 - **싱글 스레드**
    - 싱글스레드 기반이기 때문에 자바스크립트 코드가 동시에 실행될 수 없다.
    - 싱글스레드가 혼자서 일을 처리하고, 들어오는 요청 순서가 아닌 논 블로킹 방식으로 이번 작업이 완료될 때 까지 대기하지 않고 다음 작업을 수행한다.
    - Node는 CPU연산을 많이 요구하는 작업에는 적합하지지 않고, 크기가 작은 데이터를 실시간으로 주고받는데 적합하다. 특히 I/O요청이 많은 작업에 특화되어 있다. 

---
#### ⭐jwt
---
#### ⭐OAuth2
---
#### ⭐클로저(Closure) ver1.
 - 클로저(Closure)에 대한 [MDN 정의](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)
```
"A closure is the combination of a function bundled together (enclosed)
with references to its surrounding state (the **lexical environment**). 
In other words, a closure gives you access to an outer function’s scope from an inner function. 
In JavaScript, closures are created every time a function is created, at function creation time."

클로저는 함수 주변 상태(어휘 환경 :lexical environment)와 함수의 조합이다.
클로져는 우리에게 내부 함수에서 외부함수의 범위에 접근할 수 있게 한다. 
자바스크립트에서는 함수가 생성될 때마다 클로저가 생성된다.
```
   
 - 어휘적 범위지정(Lexical scping)
 - [자바스크립트 코드를 테스트할 수 있는 곳](jsfiddle.net)

```javascript
function sample() {
  var name = "mirutree";   // sample함수에 의해 생성된 지연 변수
  function displayName() { // 내부함수이며, 클로저
    console.log(name);     // 부모함수에서 선언된 변수 사용
  }
  displayName();
}
sample(); // 실행하면, "mirutree"라는 로그가 찍힌다.
```   
   
splayName()은 내부함수이고 sample() 함수 안에서만 사용할 수 있다. 그리고 displayName() 내부엔 자신만의 지역변수가 없다.      
하지만 함수 내부에서 외부함수의 변수에 접근할 수 있기 때문에 부모함수에서 선언된 변수 name에 접근할 수 있다.   
displayName()가 자신만의 name변수를 가지고 있었다면 `name` 대신 `this.name`을 사용했을 것이다.      
예시를 총해 함수가 중첩된 상황에서 어떻게 변수를 처리하는지 알 수 있다.   
어휘적 범위지정(Lexical scping)의 한 예이다.   
중첩된 함수는 외부 범위(scope)에서 선언한 변수에도 접근할 수 있다.   
   
 - 클로저(Closure)
```javascript
function outerFunc() {
  var name = "mirutree";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

var myFunc = outerFunc(); // 변수에 displayName을 리턴함 / 유효범위의 어휘적 환경 유지
myFunc(); // 리턴된 displayName 함수를 실행 (name 변수에 접근)
```
   
위의 코드는 동일한 결과가 실행되지만, displayName()함수가 실행되기도 전에 외부함수인 outerFunc()로부터 리턴되어 myFunc이라는 변수에 저장된다.   
몇 프로그래밍 언어에서 함수 안의 지역변수들은 *함수가 처리되는 동안에만 존재*한다.   
자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성하기 때문에 함수 안 지역변수들을 외부에서도 쓸 수 있다.   
클로저란? 함수와 함수가 선언된 어휘적 환경의 조합이다.    
환경은 클로저가 생성된 시점의 **유효범위 내에 있는 모든 지역 변수**로 구성된다.    
myFunc는 makeFunc이 실행될 때 셍성된 displayName함수의 인스턴스에 대한 참조다.    
displayName의 인스턴스는 변수 name이 있는 어휘적 환경에 대한 참조를 유지한다.      
이런이유로 myFunc가 호출될 때 변수 name을 사용할 수 있다.
   
---
#### ⭐리덕스
---
#### ⭐서버사이드 랜더링
---
#### ⭐cors
---
#### ⭐React의 생명 주기(Life Cycle)
 - [라이프사이클 다이어그램 링크](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
 - 모든 컴포넌트는 여러종류의 생명주기 메서드를 가진다.
 - 이 메서드를 오버라이딩하여 **특정 시점에 코드가 실행**되도록 할 수 있다.
 - **Mount** *(컴포넌트 처음 실행 - 컴포넌트의 인스턴스가 생성되어 DOM에 삽입될 때)*
    - **constructor()** 
        : 해당컴포넌트가 마운트되기 전에 호출. this.state에 객체를 할당하여 지역state를 초기회하거나 인스턴스에 이벤트처리 메서드를 바인딩할 때 사용
    - static getDerivedStateFromProps() : render() 메서드 직전에 호출. props에 있는 값을 state에 동기화시킬 때 사용
    - **render()** : 클래스 컴포넌트에서 반드시 구현되어야하는 메서드. 컴포넌트를 렌더링하는 메서드
    - **componentDidMount()** : 컴포넌트가 마운트된 직후에 호출된다. API를 통해 데이터를 가져올때 적합하다.
   
 - **Update** *(props 또는 state가 변경될 때)*
    - static getDerivedStateFromProps() : render()메서드 직전에 호출. props의 변화에 따라 state 값에도 변화를 주고 싶은 경우에 사용.
    - shouldComponentUpdate() : props또는 state를 변경했을 때, 리렌더링을 시작할지 여부를 지정하는 메서드. true면 다음 라이프사이클 계속 실행, false면 작업중지
    - **render()** : 컴포넌트 리랜더링
    - getSnapshotBeforeUpdate() : 가장 마지막으로 랜더링된 결과가 DOM에 반영되기 전에 호출. 채팅화면처름 스크롤위치가 필요한 경우 사용. 반환값은 **componentDidUpdate()** 에 인자로 전달된다.
    - **componentDidUpdate()** : 갱신이 일어난 직후 호출. 컴포넌트가 갱신되었을 때 DOM을 조작하기 위해 활용한다.
    
 - **Unmount** *(컴포넌트가 DOM에서 제거될 때)*
    - **componentWillUnmount()** : 컴포넌트가 마운트 해제되어 제거되기 직전에 호출. **componentDidMount()** 내에서 생성된 구독 해제 등 모든 정리작업을 수행한다. 이제 컴포넌트는 다시 랜더링되지 않기 때문에 setState()를 호출하면 안된다.   
   
   
---
#### ⭐Express와 미들웨어
 - **Express?** Node.js를 위한 빠르고 개방적인 간결한 웹 프레임워크 ( [Express 공식 가이드](https://expressjs.com/ko/guide/routing.html) )
 - 가장 보편적으로 쓰이는 Node.js 웹 프레임워크이다. 각종 라이브러리와 미들웨어를 내장하고 있고, 규칙을 강제하여 코드의 구조와 통일성을 향상시킨다.
 - 미들웨어(Middleware)는 운영 체제와 응용 소프트웨어 사이에서 동작하는 중간자 소프트웨어입니다. 하지만 웹에서 말하는 미들웨어는 **요청과 응답 중간에서 동작하는 것**을 말한다.
 - **Express의 미들웨어?**
    - 일종의 함수로 **req**(요청정보 객체), **res**(응답정보 객체), **next**(그 다음 미들웨어 함수에 대한 액세스 권한 함수. 호출하면 다음 미들웨어를 실행)를 가지고 있다.
    - `.use(미들웨어)` 메소드로 미들웨어를 다룬다.
 - **Express의 미들웨어 종류**
    - Application-level (app내에서 사용하는 미들웨어) : 어플리케이션 전반에서 사용
    - Router-level (라우터에서 사용하는 미들웨어) : 라우터 내 사용
    - Error-handling (에러 처리 미들웨어) : use함수에 인자로 4개의 매개변수(err, req, res, next)
    - Built-in (빌트인 미들웨어)
    - Third-party (써드파티 미들웨어) : npm으로 설치하는 미들웨어
 - **미들웨어 함수가 수행할 수 있는 것**
   -  모든 코드를 실행한다
   -  요청 및 응답 객체에 대한 변경을 실행한다
   -  요청-응답 주기를 종료한다
   -  스택 내의 그 다음 미들웨어 함수를 호출한다 (next)
  ![image](https://user-images.githubusercontent.com/63778557/147907053-e6b0364c-fe44-4d4a-a58e-b93533816bdd.png)
 - **morgan?**
    - express 미들웨어 중 하나로 로그기록을 남기는 모듈이다.
   
---
#### ⭐React의 불변성
---
#### ⭐React Hooks
 - **React Hooks?**
    - React 16.8버전에 새로 추가된 기능. 
    - 기존 class를 활용해서 Component를 설정하던 방법을 개선한 것이다. class 기반의 컴포넌트는 유지보수가 힘들었다.
    - Hooks가 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었다. 또 렌더링 후 작업을 설정하는 기능도 할 수 있다.
    - Hooks의 함수에는 **useState()와 useEffect(), useReducer**가 있다.
   
 - **useState()**
    - 상태(state)관리를 하는 함수
    - **상태(state)란?** 컴포넌트 내부에서 변경될 수 있는 값. 
   
 - **useEffect()**
    - 컴포넌트가 렌더링 될 때 마다 작업을 수행하도록 하는 함수
```javascript
// 맨처음 렌더링될 때만 실행하고 싶으면 두번째 인자에 `[]`를 넣는다
    useEffect(() => {
      console.log("마운트 될 때만 실행");
    }, []);

// 특정 state값이 변할 때마다 두번째 인자에 [상태]라고 입력하면, [상태]값에 변화가 있을 때마다 콘솔로그가 찍힌다.
    useEffect(() => {
      console.log(상태);
    }, [상태]);
```
   
 - **useReducer()**
    - 함수형 컴포넌트에서 현재 상태, 그리고 업데이트를 위한 정보를 담은 action 값을 전달받고 새로운 상태를 반환하는 함수
   
---
#### ⭐클로저(Closure) ver2.
---
#### ⭐Redux-Saga / Redux-Thunk
 - 리덕스 미들웨어
    - 리덕스 미들웨어는 리덕스가 지니고 있는 핵심 기능.
    - 리덕스 미들웨어를 사용하면 액션이 디스패치 된 다음. 리듀서에서 해당 액션을 받아와서 업데이트하기 전에 추가적인 작업을 할 수 있다.
    - 보통의 미들웨어를 사용하는 주된 이유는 비동기 작업을 처리할 때 이다. ex) 리액트 앱에서 백엔드 API를 연동
    - 누구나 만들어서 사용할 수 있지만 일반적으로 라이브러리를 설치해서 사용한다
    - 비동기 작업에 관련된 미들웨어 라이브러리 종류
      - [redux-thunk](https://github.com/reduxjs/redux-thunk)
      - [redux-saga](https://github.com/redux-saga/redux-saga)
      - redux-observable
      - redux-promise-middleware 등
   
 - redux-thunk
    - 리덕스의 창시자 Dan Abramov가 만들었다.
    - 이 미들웨어를 사용하면 **액션 객체가 아닌 함수를 디스패치**할 수 있다.
    - 함수를 디스패치 할 때에는 해당 함수에서 `dispatch`와 `getState`를 파라미터로 받아와주어야 한다.
    - 이 함수를 만들어주는 함수를 thunk라고 부른다.
   
 - redux-saga
    - 액션을 모니터링하고 있다가 특정 액션이 발생하면 이에 따라 특정 작업을 하는 방식으로 사용
    - 특정작업? 특정 자바스크립트 실행, 다른 액션을 디스패치, 현재상태를 불러오는 것 등
    - redux-saga는 redux-thunk로 못하는 다양한 작업들을 처리할 수 있다.
      1. 비동기 작업을 할 때 기존 요청 취소처리
      2. 특정 액션이 발생하면 이에 따라 다른 액션이 디스패치되거나, 자바스크립트 코드 실행
      3. 웹소켓을 사용하는 경우 Channel기능을 사용하여 효율적 코드 관리
      4. API요청이 실패했을 때 재요청
    - redux-saga는 다양한 상황에 쓸 수 있는만큼 제공되는 기능도 많고 진입장벽이 크다.
    - Generator 문법을 사용한다.
      - 이 문법의 핵심기능은 함수를 작성할 때 특정 구간에 멈춰놓거나, 원할 때 다시 돌아가게 하거나, 결과값을 여러번 반환할 수 있다.
   
 - 가장 큰 차이점
     - redux-thunk는 절대 action에 응답을 줄 수 없다
     - redux-saga는 store를 구독하고 특정 작업이 디스패치 될 때 saga가 실행되도록 유발할 수 있다.













